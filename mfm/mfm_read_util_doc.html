<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">- no title specified</title><meta name="DCTERMS.title" content="" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="David Gesswein"/><meta name="DCTERMS.issued" content="2013-12-28T10:05:51" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.modified" content="2015-11-01T19:15:41.035727193" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0in; margin-right:0in; text-indent:0in; }
	.P10 { font-size:12pt; margin-bottom:0in; margin-left:0.198in; margin-right:0in; margin-top:0in; text-indent:-0.1965in; font-family:Liberation Serif; writing-mode:page; }
	.P11 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0.5in; margin-right:0in; text-indent:0in; }
	.P12 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0.4925in; margin-right:0in; text-indent:0in; }
	.P13 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0.1457in; margin-right:0in; text-indent:0in; font-style:italic; }
	.P16 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0.15in; margin-right:0in; text-indent:0in; }
	.P2 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0in; margin-right:0in; text-indent:0in; font-style:italic; }
	.P3 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0in; margin-right:0in; text-indent:0in; }
	.P4 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0in; margin-right:0in; text-indent:0in; }
	.P5 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0in; margin-right:0in; text-indent:0in; }
	.P6 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0.1in; margin-right:0in; text-indent:0in; font-style:italic; }
	.P7 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0.1201in; margin-right:0in; text-indent:0in; }
	.P8 { font-size:12pt; font-family:Liberation Serif; writing-mode:page; margin-left:0.1201in; margin-right:0in; text-indent:0in; font-style:italic; }
	.P9 { font-size:12pt; margin-bottom:0.0835in; margin-left:0.198in; margin-right:0in; margin-top:0in; text-indent:-0.1965in; font-family:Liberation Serif; writing-mode:page; }
	.Standard { font-size:12pt; font-family:Liberation Serif; writing-mode:page; }
	.T1 { font-style:italic; }
	<!-- ODF styles with no properties representable as CSS -->
	.T2 .T3 .T4  { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:0.7874in; margin-bottom:0.7874in; margin-left:0.7874in; margin-right:0.7874in; "><p class="P10">mfm_read can analyze and/or read a MFM disk and write raw MFM transition data, decoded data, or emulation data to files.  </p><p class="P9">mfm_util can read transition and convert to emulation or decoded data. It can also read emulation file data and convert to decoded data.</p><p class="Standard">mfm_read and mfm_util both use similar command options.</p><p class="Standard">--analyze  -a <span class="T3">[=cyl,head]</span></p><p class="P12">Analyze disk format. <span class="T3">If cylinder and head is specified it will analyze the specified track for header format. No spaces can be in the optional parameters. --analyze=10,4</span></p><p class="Standard">--begin_time -b #</p><p class="P11">The number of nanoseconds to delay from index to start reading track</p><p class="Standard">--cylinders  -c #</p><p class="P11">The number of cylinders.</p><p class="Standard">--data_crc  -<span class="T4">j</span> #h,#h,#h[,#h]</p><p class="P11">The CRC/ECC parameters for the sector data area.  Initial value, polynomial, polynomial length, maximum ECC span.</p><p class="P1">--drive  -<span class="T4">d</span> #</p><p class="P11">Drive number to select for reading. Only valid for read command. <span class="T2">Drives are number 1 to 4. </span></p><p class="P1">--emulation_file -m filename</p><p class="P11">File name to write emulation bit data to. No file created if not specified</p><p class="P1">--extracted_data_file  -e filename</p><p class="P11">File name to write decoded data to. No file created if not specified.</p><p class="P1">--format  -f WD_1006 | OMTI_5510 |  DEC_RQDX3 | Xebec_104786 | Olivetti</p><p class="P11">The track format.</p><p class="Standard">--head_3bit  -3</p><p class="P11">Selects header 3 bit head encoding used by WD 1003 controller. Default is 4 bit. This will not be detected by analyze. The wrong number of heads may be selected.</p><p class="Standard">--header_crc  -g #h,#h,#h[,#h]</p><p class="P11">The CRC/ECC parameters for the sector header. Initial value, polynomial, polynomial length, maximum ECC span.</p><p class="Standard">--heads  -h #</p><p class="P11">The number of heads.</p><p class="Standard">--interleave  -i # | #,#,#,#,...</p><p class="P11">The logical sector numbers from header in physical sector order or the interleave value</p><p class="Standard">--note -n “string”</p><p class="P11">String is stored in header of transition and emulation file for information about image. mfm_util will display.</p><p class="Standard">--retries  -r #</p><p class="P11">Select number of retries on read errors. Only valid for read command. Default 50.</p><p class="Standard">--sector_length  -l #</p><p class="P11">The sector data area length in bytes. Default is 512.</p><p class="Standard">--sectors  -s #[,#]</p><p class="P11">The number of sectors per track, lowest sector number.</p><p class="P1">--transitions_file  -t filename</p><p class="P11">File name to write raw MFM transitions to. No file created if not specified. Only valid for read command.</p><p class="Standard">--quiet  -q #h</p><p class="P11">Bit mask to select which messages don't print. 0 is print all messages. Default is 1 (no debug messages). Higher bits are more important messages in general.</p><p class="Standard">--unbuffered_seek  -u</p><p class="P11">Use unbuffered/ST506 seeks. Default is buffered/ST412.</p><p class="P1">--version -v</p><p class="P11">Print program version number.</p><p class="Standard"> </p><p class="P1">Long options can be abbreviated to the shortest unique name. Option values can't have spaces unless quoted as a string.</p><p class="P1"> </p><p class="P1"># is a number. #h is a number which may be decimal, octal if starts with a 0, or hex starting with 0x.</p><p class="P1">The Cyclic Redundancy Check (CRC) / Error Correcting Code (ECC) parameters consists of a initial value which the CRC register is set to before starting the CRC, the CRC bit length, a CRC polynomial, and a maximum ECC span. The ECC span should be zero if ECC correction should not be used.</p><p class="P1"> </p><p class="P1">32 bit or longer polynomials may be usable for ECC even if the original controller only used them for CRC. The quality of the polynomial chosen determines the miss-correction probability.  Most 32 bit polynomials specify 5 bit correction though some say they can be used for up to 11 bit correction.</p><p class="P1"> </p><p class="P1">Emulation file is for use by the mfm_emu program to emulate a disk drive.  For mfm_read it is an output. For mfm_util it is an output if a transitions file is specified otherwise it is an input. </p><p class="P1"> </p><p class="P1">If extract file is specified mfm_read will attempt to decode the track data. If the disk format is known an extract file should be specified even if one is not needed since mfm_read will then reread tracks that have errors until it exceeds the error count or gets a successful read of the track. </p><p class="P1"> </p><p class="P1">Begin_time is for drives that have a sector straddle the start of the index pulse. For reading to work properly all the data must be read consecutively. Set this parameter to the time in nanoseconds the first physical sector is delayed from the index pulse. It is needed for Corvus model H and NorthStar Advantage drives.</p><p class="P3"> </p><p class="P4">NOTE: Some computers use different format on different tracks. Analyze can only handle one format at a time. This may cause it to determine the wrong number of cylinders or other parameters. The published specification for the drive should be checked against what analyze determine and the command arguments adjusted as needed.</p><p class="P4"> </p><p class="P1">Examples:</p><p class="P1"> </p><p class="P1">To read an unknown format drive</p><p class="P1">   mfm_read --analyze --transitions_file raw_data --extracted_data_file extracted_data –note “Drive from TI Professional computer read November 7 2014”</p><p class="P1"> </p><p class="P1">Analyze is conservative on maximum ECC burst length for correction. You may rerun with the command line printed and change the header or data _crc last parameter to increase ECC span with higher probability of miss correction. If you expected sector doesn't match sector found on some of the tracks the drive may have different interleave on some tracks. Try rerunning with the command parameters printed except leave off –interleave.</p><p class="P1"> </p><p class="P1">To store raw transitions without decoding (change parameters to match your drive)</p><p class="P1">   mfm_read --transitions_file raw_data --drive 1 --heads 6 --cylinders 640</p><p class="P1"> </p><p class="P1">To process previously read raw transitions data if analyze determined decoding parameters or they were manually specifed when file created:</p><p class="P1">   mfm_util --transitions_file raw_out2 --extracted_data_file /tmp/decoded_out </p><p class="P1">Otherwise specify parameters for your drive like:</p><p class="P1">   mfm_util --sectors 17,0 --heads 6 --cylinders 640 --header_crc 0x2605fb9c,0x104c981,32,0 --data_crc  0xd4d7ca20,0x104c981,32,0 --format OMTI_5510 --sector_length 512 --interleave 0,3,6,9,12,15,1,4,7,10,13,16,2,5,8,11,14 --transitions_file raw_out2 --extracted_data_file /tmp/decoded_out </p><p class="P1"> </p><p class="P1">--emulation_file may be specified instead of  --transitions_file to convert emulation file to extracted data.</p><p class="P1"> </p><p class="P1"> </p><p class="P1"> </p><p class="P1">Analysis typical messages. Explanation in italic:</p><p class="P2"> </p><p class="P1">AM33XX</p><p class="P1">File prucode0.bin open passed</p><p class="P2">   Informational messages from PRU access routines.</p><p class="P1">Found drive at select 2</p><p class="P1">   <span class="T1">Informational. Select line drive responded to.</span></p><p class="P1">Returning to track 0</p><p class="P1">   <span class="T1">Informational. This operation may take a while.</span></p><p class="P1">Drive RPM 3594.4</p><p class="P1">   <span class="T1">Informational. Drive should be close to 3600 RPM</span></p><p class="P5">Matches count 34 for controller OMTI_5510</p><p class="P5">Header CRC: Polynomial 0x104c981 length 32 initial value 0x2605fb9c</p><p class="P5">Sector length 512</p><p class="P5">Data CRC: Polynomial 0x104c981 length 32 initial value 0xd4d7ca20</p><p class="P5">Number of heads 6 number of sectors 17 first sector 0</p><p class="P16">I<span class="T1">nformational. What we found about the disk format. Sometimes multiple formats will be shown. The code will retry on a different cylinder to try to determine correct format. The  matches can either be false matches or some drives  such as DEC RQDX3 use multiple formats. This code does not deal well with that. You can manually read with the different formats and put the data back together.</span></p><p class="P5">Interleave (not checked): 0 3 6 9 12 15 1 4 7 10 13 16 2 5 8 11 14</p><p class="P13">Informational. If it can't determine interleave the disk can still be read and decoded. Interleave is only checked if interleave is specified on the command line. Too many drives have tracks with different interleave which generated confusing messages.</p><p class="P1">Drive supports buffered seeks (ST412)</p><p class="P1">   <span class="T1"> Informational. </span></p><p class="P1">No sectors readable from cylinder 640</p><p class="P1">Stopping end of disk search due to two unreadable tracks in a row </p><p class="P1">Number of cylinders 640, 33.4 MB</p><p class="P1">   <span class="T1"> Informational.  The method we used to determine the number of cylinders and size determined.</span></p><p class="P1">Command line to read disk: </p><p class="P1">--sectors 17,0 --heads 6 --cylinders 640 --header_crc 0x2605fb9c,0x104c981,32,0 --data_crc  0xd4d7ca20,0x104c981,32,0 --format OMTI_5510 --sector_length 512 --retries 50 --drive 2 --interleave 0,3,6,9,12,15,1,4,7,10,13,16,2,5,8,11,14</p><p class="P6">This is the options needed to decode the disk with mfm_read. For mfm_util remove --retries and --drive from options. Change header_crc and/or data_crc last parameter if you wish to use different  ECC maximum span. Remove interleave if you get expected sector doesn't match sector found errors.</p><p class="P2"> </p><p class="P1">It is recommended to verify results of analysis since it can make mistakes.</p><p class="P1"> </p><p class="P1">Decoding messages:</p><p class="P1">AM33XX</p><p class="P1">File prucode0.bin open passed </p><p class="P2">   Informational messages from PRU access routines in mfm_read.</p><p class="P1">Returning to track 0</p><p class="P1">   <span class="T1">Informational. This operation may take a while. Only mfm_read.</span></p><p class="P1">Retries failed cyl 22 head 0</p><p class="P1">   <span class="T1">Unable to recover all data from the specified track. Only mfm_read.</span></p><p class="P1">Bad sectors on cylinder 22 head 0: 3 15H</p><p class="P8">Indicates that for the specified track that data of sector 3 has uncorrected errors and the header for sector 15 has errors. If the header has an error the data will be all zero.</p><p class="P1">ECC Corrections on cylinder 56 head 5: 1(2) 13(4) 15(1H) </p><p class="P8">Informational. Indicates that for the specified track that data of sectors 1 and 13 were corrected and the header of sector 15 corrected. The number in the parenthesis is the length of the bit pattern corrected. Unless the ECC correction had a false correction the data is good.</p><p class="P1">Cyl 59 head 2 Missed sector between 12(4) and 1(6)</p><p class="P7"> <span class="T1">Informational. Indicates that the sectors found didn't match the interleave specified. The first number is the sector header number and the number in parenthesis the physical sector starting with 0. A bad sector message will be printed if the data is bad. Some disks vary the interleave. Try again without the interleave option.</span></p><p class="P1">Good data after 20 Retries cyl 219 head 0</p><p class="P1">   <span class="T1">Informational. Indicates we recovered good data by retrying the read.</span></p><p class="P1">Found cyl 0 to 639, head 0 to 5, sector 0 to 16</p><p class="P1">   <span class="T1">Informational. Should match what was specified</span></p><p class="P1">Expected 65280 sectors got 65276 good sectors, 0 bad header, 4 bad data </p><p class="P1">11 sectors corrected with ECC. Max bits in burst corrected 5 </p><p class="P1">   <span class="T1">Summary of errors during the read. We have 4 sectors with bad data.</span></p><p class="P1"> </p><p class="P1">Errors:</p><p class="P1">Command 4 fault 300 status 1002c</p><p class="P1">Not Write fault</p><p class="P1">Not Seek complete</p><p class="P1">Not Index</p><p class="P1">Ready</p><p class="P1">Drive selected</p><p class="P1">Not Track 0</p><p class="P8">This indicates a command failed. See cmd.h for definitions. Status is the drive status bits which are decoded in text below. This error was the drive did not give seek complete in the expected time. These are normally fatal and the program will exit. Some are recovered from during analysis and are informational.</p></body></html>